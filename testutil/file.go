package testutil

import (
	"os"
	"os/exec"
	"os/user"
	"runtime"
	"testing"

	"github.com/pkg/errors"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TempStringFile creates a temporary file with
// the provided contents (as string) and returns its path.
// The file is automatically deleted once the test finishes.
func TempStringFile(t *testing.T, contents string) string {
	return TempFileByPattern(t, "", []byte(contents))
}

// TempFileByPattern creates a temporary file with
// the provided contents (as bytes) and returns its path.
// The filename is generated by os.CreateTemp using the provided pattern.
// The file is automatically deleted once the test finishes.
func TempFileByPattern(t *testing.T, pattern string, contents []byte) string {
	f, err := os.CreateTemp("", pattern)
	require.NoError(t, err)
	defer func() {
		err := f.Close()
		assert.NoError(t, err)
	}()
	t.Cleanup(func() {
		err := os.Remove(f.Name())
		assert.NoError(t, err)
	})
	if len(contents) > 0 {
		n, err := f.Write(contents)
		require.NoError(t, err)
		require.Equal(t, len(contents), n)
	}
	return f.Name()
}

// TODO: Consider using platform-specific implementations instead of checking OS on runtime (would allow using 'golang.org/x/sys/windows').

// MakeInaccessible makes the file or directory at the provided path non-readable to the user running the test.
// On Unix, this is done by zeroing out the permission bits.
// On Windows, that method can only be used to control the "write" flag (https://golang.org/pkg/os/#Chmod),
// so we invoke 'icacls' instead to deny access (https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).
// Files and (except on Windows) directories being inaccessible don't prevent their deletion on any of the tested platforms.
//
// As this function is mainly designed for use within a temporary directory created with T.TestDir,
// the accessibility change only needs to be reverted when it prevents the file from being deleted after the test.
// This is not a problem on Linux nor Mac, but on Windows, inaccessible directories cannot be deleted.
// For this reason, the function returns a cleanup function for reverting the change.
func MakeInaccessible(path string) (func() error, error) {
	//goland:noinspection GoBoolExpressions
	if runtime.GOOS == "windows" {
		u, err := user.Current()
		if err != nil {
			return nil, errors.Wrapf(err, "cannot resolve current Windows user")
		}
		// Deprecated variant - kept here in case we ever encounter a box that's unable to use 'icacls'.
		//cmd := exec.Command("cacls", path, "/e", "/d", u.Username)
		cmd := exec.Command("icacls", path, "/deny", u.Username+":r")
		cleanup := func() error {
			// Deprecated variant - kept here in case we ever encounter a box that's unable to use 'icacls'.
			//cmd := exec.Command("cacls", dirPath, "/e", "/g", u.Username+":f")
			cmd := exec.Command("icacls", path, "/grant", u.Username+":f")
			return runCommand(cmd)
		}
		return cleanup, runCommand(cmd)
	}

	// Not Windows.
	info, err := os.Stat(path)
	if err != nil {
		return nil, err
	}
	mode := info.Mode()
	cleanup := func() error {
		return os.Chmod(path, mode)
	}
	return cleanup, os.Chmod(path, 0)
}

// MakeInaccessibleT wraps MakeInaccessible with error handling and automatic cleanup using the provided testing.T object.
func MakeInaccessibleT(t *testing.T, path string) {
	cleanup, err := MakeInaccessible(path)
	require.NoErrorf(t, err, "cannot make file or directory %q inaccessible", path)
	if cleanup != nil {
		t.Cleanup(func() {
			err := cleanup()
			assert.NoErrorf(t, err, "cannot restore accessibility of file or directory %q", path)
		})
	}
}

func runCommand(cmd *exec.Cmd) error {
	out, err := cmd.CombinedOutput()
	return errors.Wrapf(err, string(out))
}
